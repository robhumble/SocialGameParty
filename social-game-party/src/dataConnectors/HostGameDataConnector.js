import DataConnector from "@/dataConnectors/DataConnector";
//import { SessionUser } from "@/logic/SessionInfo.js";
import * as sgf from "@/logic/socialGameFramework.js";


/**
 * Data connector for Game Data that the host needs to listen to.
 */
export default class HostGameDataConnector extends DataConnector {

  constructor() {
    super();
  } 

  #connectorCollectionName = "hostGameData";

  
  //General Functions--------------------------------------------


  makeHostGameData = async function (roomName) {

    let hostDataDbModel = this.buildHostGameDataDbModel();

    var existingDoc = await this.firestoreDb.collection(this.#connectorCollectionName).doc(roomName).get();

    if (existingDoc.data())
      throw Error("Document already exists!");

    // This line creates both the document and the data inside of it
    this.firestoreDb.doc(`${this.#connectorCollectionName}/${roomName}`).set(hostDataDbModel);

  };




 //Stores the unsubscribe function generated by firestore when we setup a listener.
 unsubscribeToHostGameDataFunc = null;

 
 listenToHostGameData = function (onSnapshotFunction, roomName) {

   //Don't subscribe to multiple rooms
   if (this.unsubscribeToHostGameDataFunc)
     this.unsubscribeToHostGameData();

   //While this should be a listener, I am concerned changes that aren't the userlist will be sent. 
   this.unsubscribeToHostGameDataFunc = this.firestoreDb
     .collection(this.#connectorCollectionName)
     .doc(roomName)
     .onSnapshot(function (doc) {

       let docData = doc.data();

       if (docData) {
         let remoteHostGameData = {      

          results: docData.results,          
          dynamicHostGameData: docData.dynamicHostGameData

         }
         onSnapshotFunction(remoteHostGameData);
       }
     });
 };

 unsubscribeToHostGameData = function () {
   if (this.unsubscribeToHostGameDataFunc) {
     this.unsubscribeToHostGameDataFunc();
     sgf.mainFramework.megaLog("Unsubscribed to HostGameData!");
     this.unsubscribeToHostGameDataFunc = null;
   }
   else
     sgf.mainFramework.megaLog("No HostGameData to unsubscribe from!");
 }

  /**
   * Delete the specified HostGameData from the HostGameData collection.
   * @param {string} roomName 
   */
  deleteHostGameData = function (roomName) {

    this.firestoreDb.collection(this.#connectorCollectionName).doc(roomName).delete()
      .then(
        sgf.mainFramework.megaLog(`HostGameData "${roomName}" has been deleted. `)
      ).catch(err => {
        sgf.mainFramework.megaLog("There was an issue deleting the HostGameData: " + err);
      });

  }



//Migrated from GamePlayDataConnector -------------------------------------->



 /**
   * Update the HostGameData by passing in a function.
   * @param {string} roomName 
   * @param {function} updateFunc - function takes the current HostGameData data as an arg
   */
  updateWholeHostGameDataViaFunction = function (roomName, updateFunc) {
    //let that = this;

    let docRef = this.firestoreDb.doc(`${this.#connectorCollectionName}/${roomName}`);

    this.firestoreDb.runTransaction(function (transaction) {
      return transaction.get(docRef).then(function (targetDoc) {

        let curDocData = targetDoc.data();
        let updatedDocData = updateFunc(curDocData);

        transaction.update(docRef, updatedDocData);
      })
    })
  }


/**
   * Quick version of the base dataConnector batch funcitons that specifically targets the HostGameData collection
   * @param {object} batch 
   * @param {string} operation 
   * @param {string} roomName 
   * @param {object} dataToUpdate 
   */
  hostGameDataAddToBatch(batch, operation, roomName, dataToUpdate) {
    let ref = this.firestoreDb.collection(this.#connectorCollectionName).doc(roomName);

    switch (operation) {
      case "set": batch.set(ref, dataToUpdate); break;
      case "update": batch.update(ref, dataToUpdate); break;
      case "delete": batch.delete(ref); break;
    }

    return batch;
  }



     /**
   * Clear the game related data in the ActivePlayerGameData document.
   * @param {string} roomName 
   */
  resetHostGameData = function (roomName) {
    this.updateWholeHostGameDataViaFunction(roomName, (docData) => {

      //docData.currentStep = null;
      //docData.dynamicPlayerGameData = {};
      //docData.spectatorGameData = {};
      //docData.currentCheckInstructions = null;
      //docData.currentInstructions = null;
      //docData.hostId = null

      docData.results = [];
      docData.dynamicHostGameData= {};

      return docData;
    });
  }



















  //Private Helpers-------------------------------------->

  buildHostGameDataDbModel = function () {
    let dbModel = {

      results: [],

      //This is a general container for data that needs to be stored by the current game.
      dynamicHostGameData: {},  //Dynamically generated data that only active players care about (probably private, and also only stuff that is relevant to other active players)
    }

    return dbModel;
  }

}